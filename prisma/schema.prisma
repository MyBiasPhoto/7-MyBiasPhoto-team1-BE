generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 Int                 @id @default(autoincrement())
  email              String              @unique
  nickname           String
  password           String?
  provider           AuthProvider        @default(LOCAL)
  providerId         String?
  points             Int                 @default(0)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  photoCards         PhotoCard[]         @relation("OwnerCards")
  ownedCards         UserCard[]          @relation("UserOwnedCards")
  sales              Sale[]              @relation("SellerSales")
  purchases          Purchase[]          @relation("BuyerPurchases")
  proposals          ExchangeProposal[]  @relation("ProposingUser")
  notifications      Notification[]
  pointLogs          PointLog[]
  cardCreationLimits CardCreationLimit[]
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

model PhotoCard {
  id            Int        @id @default(autoincrement())
  name          String
  description   String?
  imageUrl      String
  grade         CardGrade
  genre         CardGenre
  initialPrice  Int
  totalQuantity Int
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  creatorId     Int
  creator       User       @relation("OwnerCards", fields: [creatorId], references: [id])
  userCards     UserCard[]
  sales         Sale[]     @relation("PhotoCardToSale")
}

model UserCard {
  id                Int                @id @default(autoincrement())
  isOnSale          Boolean            @default(false)
  createdAt         DateTime           @default(now())
  ownerId           Int
  owner             User               @relation("UserOwnedCards", fields: [ownerId], references: [id])
  photoCardId       Int
  photoCard         PhotoCard          @relation(fields: [photoCardId], references: [id])
  sales             Sale[]
  exchangeProposals ExchangeProposal[]
}

model Sale {
  id           Int                @id @default(autoincrement())
  sellerId     Int
  seller       User               @relation("SellerSales", fields: [sellerId], references: [id])
  userCardId   Int
  userCard     UserCard           @relation(fields: [userCardId], references: [id])
  photoCardId  Int
  photoCard    PhotoCard          @relation("PhotoCardToSale", fields: [photoCardId], references: [id])
  price        Int
  status       SaleStatus         @default(ON_SALE)
  desiredGrade CardGrade?
  desiredGenre CardGenre?
  desiredDesc  String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  proposals    ExchangeProposal[]
  purchases    Purchase[]
}

// ⚠️ Prisma에서는 View를 테이블처럼 인식하지 않기 때문에 주의가 필요함
// 1. `@@ignore`를 추가한 상태에서 `prisma migrate`를 실행해야 migration 충돌이 없음
// 2. 이후 `@@ignore`를 제거하고 `npx prisma generate`를 실행해야 client에서 view에 접근 가능함
//
// - migration = @@ignore O
// - generate  = @@ignore X
model SaleMarketSummary {
  photoCardId     Int
  price           Int
  sellerId        Int
  nickname        String
  totalRegistered Int
  totalOnSale     Int
  createdAt       DateTime
  name            String
  imageUrl        String
  grade           CardGrade
  genre           CardGenre
  creatorId       Int

  @@id([photoCardId, sellerId])
  @@map("sale_market_summary") // 실제 뷰 이름
}

model Purchase {
  id        Int      @id @default(autoincrement())
  buyer     User     @relation("BuyerPurchases", fields: [buyerId], references: [id])
  buyerId   Int
  sale      Sale     @relation(fields: [saleId], references: [id])
  saleId    Int
  createdAt DateTime @default(now())
}

model ExchangeProposal {
  id             Int            @id @default(autoincrement())
  saleId         Int
  sale           Sale           @relation(fields: [saleId], references: [id])
  proposedCardId Int
  proposedCard   UserCard       @relation(fields: [proposedCardId], references: [id])
  proposerId     Int
  proposer       User           @relation("ProposingUser", fields: [proposerId], references: [id])
  status         ProposalStatus @default(PENDING)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

model Notification {
  id        Int              @id @default(autoincrement())
  user      User             @relation(fields: [userId], references: [id])
  userId    Int
  content   String
  type      NotificationType
  createdAt DateTime         @default(now())
  read      Boolean          @default(false)
}

model PointLog {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  amount    Int
  reason    String
  createdAt DateTime @default(now())
}

model CardCreationLimit {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  month     Int
  year      Int
  created   Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, month, year])
}

enum CardGrade {
  COMMON
  RARE
  SUPER_RARE @map("SUPER_RARE")
  LEGENDARY
}

// NOTE: 현재 CardGenre ENUM은 제공되는 시딩데이터 장르 기준으로 정의
// 서비스 요구사항에 따라 장르 항목을 변경하거나 추가할 경우,
// 아래 두 항목을 반드시 함께 수정해야 합니다:
// - Prisma 스키마 파일 (schema.prisma)
// - Zod 스키마 정의 (예: getSaleListSchema 등)
//
// 이 두 정의가 불일치할 경우, 데이터 검증 오류 또는 런타임 에러가 발생할 수 있습니다.
enum CardGenre {
  ALBUM
  SPECIAL
  FANSIGN
  SEASON_GREETING
  FANMEETING
  CONCERT
  MD
  COLLAB
  FANCLUB
  ETC
}

enum SaleStatus {
  ON_SALE
  SOLD_OUT
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum NotificationType {
  EXCHANGE_PROPOSAL_RECEIVED
  EXCHANGE_PROPOSAL_DECIDED
  CARD_PURCHASED
  CARD_SOLD_OUT
  RANDOM_BOX
}
